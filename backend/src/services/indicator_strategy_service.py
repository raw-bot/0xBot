"""
Professional indicator-based trading strategy.

Strategy Rules:
==============

ENTRY CONDITIONS (ALL must be true for entry):
1. Trend Filter: Price > EMA(50)
2. Momentum: EMA(9) > EMA(21)
3. Oversold: RSI(14) < 40
4. Liquidity: Volume > 24h_avg

OR (Alternative Entry - Breakout):
1. Breakout: Price closes above recent high (20-period)
2. Confirmation: RSI > 60
3. Volume: Volume > 24h_avg

EXIT CONDITIONS (ANY hit):
1. Hard Stop-Loss: -2.5% from entry
2. Take Profit: +5% from entry
3. Time Exit: Hold > 24 hours → close
4. RSI Overbought: RSI > 80 → take 50%, trailing on rest

POSITION SIZING:
- Base: 10% of capital (with Kelly adjustment)
- Max: 25% of capital
- Kelly Criterion based on win rate
"""

import logging
from dataclasses import dataclass
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types."""

    BUY_PULLBACK = "buy_pullback"  # Pullback to EMA in uptrend
    BUY_BREAKOUT = "buy_breakout"  # Breakout above resistance
    SELL_SHORT = "sell_short"  # Short entry on breakdown
    CLOSE_LONG = "close_long"  # Exit long position
    CLOSE_SHORT = "close_short"  # Exit short position
    HOLD = "hold"  # Hold current position
    NO_SIGNAL = "no_signal"  # No trade


@dataclass
class IndicatorSignal:
    """Signal generated by indicator analysis."""

    symbol: str
    signal_type: SignalType
    confidence: Decimal  # 0.0 to 1.0
    entry_price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    size_pct: Decimal = Decimal("0.10")
    leverage: int = 1
    reasoning: str = ""
    timestamp: Optional[str] = None


class IndicatorStrategyService:
    """Generate trading signals using professional indicators."""

    # Indicator parameters
    RSI_PERIOD = 14
    EMA_FAST = 9
    EMA_SLOW = 21
    EMA_TREND = 50

    # Entry thresholds
    RSI_OVERSOLD = 40
    RSI_OVERBOUGHT = 80
    RSI_BREAKOUT = 60

    # Risk/Reward
    STOP_LOSS_PCT = Decimal("0.025")  # 2.5%
    TAKE_PROFIT_PCT = Decimal("0.05")  # 5%

    # Position sizing
    BASE_SIZE_PCT = Decimal("0.10")  # 10%
    MAX_SIZE_PCT = Decimal("0.25")  # 25%

    def __init__(self):
        """Initialize strategy."""
        pass

    def generate_signal(
        self,
        symbol: str,
        market_snapshot: Dict[str, Any],
        current_position: Optional[Dict[str, Any]] = None,
    ) -> IndicatorSignal:
        """
        Generate trading signal for a symbol based on indicators.

        Args:
            symbol: Trading symbol (e.g., "BTC/USDT")
            market_snapshot: Market data with OHLCV and indicators
            current_position: Current open position (if any)

        Returns:
            IndicatorSignal with trading recommendation
        """
        try:
            # Extract indicator values
            price = Decimal(str(market_snapshot.get("price", 0)))
            rsi = Decimal(str(market_snapshot.get("rsi", 50)))
            ema_fast = Decimal(str(market_snapshot.get("ema_fast", 0)))
            ema_slow = Decimal(str(market_snapshot.get("ema_slow", 0)))
            ema_trend = Decimal(str(market_snapshot.get("ema_trend", 0)))
            volume_24h = market_snapshot.get("volume_24h", 0)
            current_volume = market_snapshot.get("current_volume", volume_24h)

            # Volume check (must have liquidity)
            has_volume = current_volume >= Decimal(volume_24h) * Decimal("0.8")

            # ============ EXIT SIGNALS (Priority 1) ============

            if current_position:
                exit_signal = self._check_exit_signals(symbol, price, current_position, rsi)
                if exit_signal and exit_signal.signal_type != SignalType.HOLD:
                    return exit_signal

            # ============ ENTRY SIGNALS ============

            # Signal 1: Pullback to EMA in uptrend
            pullback_signal = self._check_pullback_entry(
                symbol, price, rsi, ema_fast, ema_slow, ema_trend, has_volume
            )
            if pullback_signal and pullback_signal.signal_type != SignalType.NO_SIGNAL:
                return pullback_signal

            # Signal 2: Breakout
            breakout_signal = self._check_breakout_entry(symbol, market_snapshot, rsi, has_volume)
            if breakout_signal and breakout_signal.signal_type != SignalType.NO_SIGNAL:
                return breakout_signal

            # No valid signal
            return IndicatorSignal(
                symbol=symbol,
                signal_type=SignalType.NO_SIGNAL,
                confidence=Decimal("0.0"),
                reasoning="No entry criteria met",
            )

        except Exception as e:
            logger.error(f"Error generating signal for {symbol}: {e}")
            return IndicatorSignal(
                symbol=symbol,
                signal_type=SignalType.NO_SIGNAL,
                confidence=Decimal("0.0"),
                reasoning=f"Error: {str(e)}",
            )

    def _check_exit_signals(
        self,
        symbol: str,
        current_price: Decimal,
        position: Dict[str, Any],
        rsi: Decimal,
    ) -> Optional[IndicatorSignal]:
        """Check if position should be exited."""
        entry_price = Decimal(str(position.get("entry_price", 0)))
        side = position.get("side", "long")
        stop_loss = Decimal(str(position.get("stop_loss", 0)))
        take_profit = Decimal(str(position.get("take_profit", 0)))

        # Check hard stops
        if side == "long":
            if current_price <= stop_loss:
                return IndicatorSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=Decimal("1.0"),
                    reasoning=f"Stop loss hit at {current_price}",
                )

            if current_price >= take_profit:
                return IndicatorSignal(
                    symbol=symbol,
                    signal_type=SignalType.CLOSE_LONG,
                    confidence=Decimal("1.0"),
                    reasoning=f"Take profit hit at {current_price}",
                )

            # Check RSI overbought (partial exit)
            if rsi > self.RSI_OVERBOUGHT and current_price > entry_price:
                pnl_pct = ((current_price - entry_price) / entry_price) * Decimal("100")
                if pnl_pct >= Decimal("2.0"):  # At least 2% profit
                    return IndicatorSignal(
                        symbol=symbol,
                        signal_type=SignalType.CLOSE_LONG,
                        confidence=Decimal("0.70"),
                        reasoning=f"RSI overbought ({rsi:.0f}), take partial profit",
                    )

        return None

    def _check_pullback_entry(
        self,
        symbol: str,
        price: Decimal,
        rsi: Decimal,
        ema_fast: Decimal,
        ema_slow: Decimal,
        ema_trend: Decimal,
        has_volume: bool,
    ) -> Optional[IndicatorSignal]:
        """Check pullback entry conditions."""

        # Condition 1: Trend filter (price > EMA50)
        if price <= ema_trend or ema_trend == 0:
            return None

        # Condition 2: Momentum (EMA9 > EMA21)
        if ema_fast <= ema_slow or ema_fast == 0 or ema_slow == 0:
            return None

        # Condition 3: Oversold (RSI < 40)
        if rsi >= self.RSI_OVERSOLD or rsi == 0:
            return None

        # Condition 4: Volume
        if not has_volume:
            return None

        # Calculate confidence based on RSI
        confidence = self._calculate_pullback_confidence(rsi)

        # Calculate SL/TP
        stop_loss = price * (Decimal("1.0") - self.STOP_LOSS_PCT)
        take_profit = price * (Decimal("1.0") + self.TAKE_PROFIT_PCT)

        return IndicatorSignal(
            symbol=symbol,
            signal_type=SignalType.BUY_PULLBACK,
            confidence=confidence,
            entry_price=price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            size_pct=self.BASE_SIZE_PCT,
            leverage=1,
            reasoning=(
                f"Pullback entry: Price > EMA50, EMA9 > EMA21, "
                f"RSI {rsi:.0f} (oversold), Volume OK"
            ),
        )

    def _check_breakout_entry(
        self,
        symbol: str,
        market_snapshot: Dict[str, Any],
        rsi: Decimal,
        has_volume: bool,
    ) -> Optional[IndicatorSignal]:
        """Check breakout entry conditions."""

        price = Decimal(str(market_snapshot.get("price", 0)))
        ohlcv = market_snapshot.get("ohlcv_1h", [])

        if not ohlcv or len(ohlcv) < 20:
            return None

        # Get 20-period high (handle both OHLCV objects and dicts)
        highs = []
        for c in ohlcv[-20:]:
            if hasattr(c, "high"):
                highs.append(Decimal(str(c.high)))
            elif isinstance(c, dict):
                highs.append(Decimal(str(c.get("high", 0))))
            else:
                highs.append(Decimal("0"))
        recent_high = max(highs) if highs else Decimal("0")

        # Condition 1: Breakout above 20-period high
        if price <= recent_high:
            return None

        # Condition 2: RSI confirmation (RSI > 60)
        if rsi <= self.RSI_BREAKOUT:
            return None

        # Condition 3: Volume
        if not has_volume:
            return None

        # Calculate confidence
        breakout_pct = ((price - recent_high) / recent_high) * Decimal("100")
        confidence = min(Decimal("0.80"), Decimal("0.60") + (breakout_pct / Decimal("10")))

        # Calculate SL/TP
        stop_loss = recent_high * (Decimal("1.0") - Decimal("0.015"))  # 1.5% below breakout
        take_profit = price * (Decimal("1.0") + self.TAKE_PROFIT_PCT)

        return IndicatorSignal(
            symbol=symbol,
            signal_type=SignalType.BUY_BREAKOUT,
            confidence=confidence,
            entry_price=price,
            stop_loss=stop_loss,
            take_profit=take_profit,
            size_pct=self.BASE_SIZE_PCT,
            leverage=1,
            reasoning=(
                f"Breakout entry: Price broke {recent_high} (+{breakout_pct:.2f}%), "
                f"RSI {rsi:.0f}, Volume OK"
            ),
        )

    def _calculate_pullback_confidence(self, rsi: Decimal) -> Decimal:
        """Calculate confidence based on RSI depth."""
        # Lower RSI = more oversold = higher confidence
        if rsi <= 20:
            return Decimal("0.90")
        elif rsi <= 30:
            return Decimal("0.80")
        elif rsi <= 40:
            return Decimal("0.70")
        else:
            return Decimal("0.50")

    def validate_signal(self, signal: IndicatorSignal) -> Tuple[bool, str]:
        """
        Validate that a signal meets minimum criteria.

        Returns:
            (is_valid, reason)
        """
        # Signal must have minimum confidence
        if signal.confidence < Decimal("0.65"):
            return False, f"Low confidence: {signal.confidence:.0%}"

        # Entry signals must have SL/TP
        if signal.signal_type in [
            SignalType.BUY_PULLBACK,
            SignalType.BUY_BREAKOUT,
            SignalType.SELL_SHORT,
        ]:
            if not signal.stop_loss or not signal.take_profit:
                return False, "Missing stop loss or take profit"

            # Validate R/R ratio (reward >= 1.5x risk)
            risk = signal.entry_price - signal.stop_loss
            reward = signal.take_profit - signal.entry_price

            if risk > 0 and reward / risk < Decimal("1.5"):
                return False, f"Bad R/R ratio: {reward/risk:.2f}x (need 1.5x+)"

        # Position size validation
        if signal.size_pct < self.BASE_SIZE_PCT * Decimal("0.5"):
            return False, f"Size too small: {signal.size_pct:.0%}"

        if signal.size_pct > self.MAX_SIZE_PCT:
            return False, f"Size too large: {signal.size_pct:.0%}"

        return True, "Valid signal"
